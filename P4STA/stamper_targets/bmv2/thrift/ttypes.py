#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#
import sys

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class BmMatchParamType:
  EXACT = 0
  LPM = 1
  TERNARY = 2
  VALID = 3
  RANGE = 4

  _VALUES_TO_NAMES = {
    0: "EXACT",
    1: "LPM",
    2: "TERNARY",
    3: "VALID",
    4: "RANGE",
  }

  _NAMES_TO_VALUES = {
    "EXACT": 0,
    "LPM": 1,
    "TERNARY": 2,
    "VALID": 3,
    "RANGE": 4,
  }

class TableOperationErrorCode:
  TABLE_FULL = 1
  INVALID_HANDLE = 2
  EXPIRED_HANDLE = 3
  COUNTERS_DISABLED = 4
  METERS_DISABLED = 5
  AGEING_DISABLED = 6
  INVALID_TABLE_NAME = 7
  INVALID_ACTION_NAME = 8
  WRONG_TABLE_TYPE = 9
  INVALID_MBR_HANDLE = 10
  MBR_STILL_USED = 11
  MBR_ALREADY_IN_GRP = 12
  MBR_NOT_IN_GRP = 13
  INVALID_GRP_HANDLE = 14
  GRP_STILL_USED = 15
  EMPTY_GRP = 16
  DUPLICATE_ENTRY = 17
  BAD_MATCH_KEY = 18
  INVALID_METER_OPERATION = 19
  DEFAULT_ACTION_IS_CONST = 20
  DEFAULT_ENTRY_IS_CONST = 21
  NO_DEFAULT_ENTRY = 22
  INVALID_ACTION_PROFILE_NAME = 23
  NO_ACTION_PROFILE_SELECTION = 24
  IMMUTABLE_TABLE_ENTRIES = 25
  BAD_ACTION_DATA = 26
  ERROR = 100

  _VALUES_TO_NAMES = {
    1: "TABLE_FULL",
    2: "INVALID_HANDLE",
    3: "EXPIRED_HANDLE",
    4: "COUNTERS_DISABLED",
    5: "METERS_DISABLED",
    6: "AGEING_DISABLED",
    7: "INVALID_TABLE_NAME",
    8: "INVALID_ACTION_NAME",
    9: "WRONG_TABLE_TYPE",
    10: "INVALID_MBR_HANDLE",
    11: "MBR_STILL_USED",
    12: "MBR_ALREADY_IN_GRP",
    13: "MBR_NOT_IN_GRP",
    14: "INVALID_GRP_HANDLE",
    15: "GRP_STILL_USED",
    16: "EMPTY_GRP",
    17: "DUPLICATE_ENTRY",
    18: "BAD_MATCH_KEY",
    19: "INVALID_METER_OPERATION",
    20: "DEFAULT_ACTION_IS_CONST",
    21: "DEFAULT_ENTRY_IS_CONST",
    22: "NO_DEFAULT_ENTRY",
    23: "INVALID_ACTION_PROFILE_NAME",
    24: "NO_ACTION_PROFILE_SELECTION",
    25: "IMMUTABLE_TABLE_ENTRIES",
    26: "BAD_ACTION_DATA",
    100: "ERROR",
  }

  _NAMES_TO_VALUES = {
    "TABLE_FULL": 1,
    "INVALID_HANDLE": 2,
    "EXPIRED_HANDLE": 3,
    "COUNTERS_DISABLED": 4,
    "METERS_DISABLED": 5,
    "AGEING_DISABLED": 6,
    "INVALID_TABLE_NAME": 7,
    "INVALID_ACTION_NAME": 8,
    "WRONG_TABLE_TYPE": 9,
    "INVALID_MBR_HANDLE": 10,
    "MBR_STILL_USED": 11,
    "MBR_ALREADY_IN_GRP": 12,
    "MBR_NOT_IN_GRP": 13,
    "INVALID_GRP_HANDLE": 14,
    "GRP_STILL_USED": 15,
    "EMPTY_GRP": 16,
    "DUPLICATE_ENTRY": 17,
    "BAD_MATCH_KEY": 18,
    "INVALID_METER_OPERATION": 19,
    "DEFAULT_ACTION_IS_CONST": 20,
    "DEFAULT_ENTRY_IS_CONST": 21,
    "NO_DEFAULT_ENTRY": 22,
    "INVALID_ACTION_PROFILE_NAME": 23,
    "NO_ACTION_PROFILE_SELECTION": 24,
    "IMMUTABLE_TABLE_ENTRIES": 25,
    "BAD_ACTION_DATA": 26,
    "ERROR": 100,
  }

class CounterOperationErrorCode:
  INVALID_COUNTER_NAME = 1
  INVALID_INDEX = 2
  ERROR = 3

  _VALUES_TO_NAMES = {
    1: "INVALID_COUNTER_NAME",
    2: "INVALID_INDEX",
    3: "ERROR",
  }

  _NAMES_TO_VALUES = {
    "INVALID_COUNTER_NAME": 1,
    "INVALID_INDEX": 2,
    "ERROR": 3,
  }

class SwapOperationErrorCode:
  CONFIG_SWAP_DISABLED = 1
  ONGOING_SWAP = 2
  NO_ONGOING_SWAP = 3

  _VALUES_TO_NAMES = {
    1: "CONFIG_SWAP_DISABLED",
    2: "ONGOING_SWAP",
    3: "NO_ONGOING_SWAP",
  }

  _NAMES_TO_VALUES = {
    "CONFIG_SWAP_DISABLED": 1,
    "ONGOING_SWAP": 2,
    "NO_ONGOING_SWAP": 3,
  }

class MeterOperationErrorCode:
  INVALID_METER_NAME = 1
  INVALID_INDEX = 2
  BAD_RATES_LIST = 3
  INVALID_INFO_RATE_VALUE = 4
  INVALID_BURST_SIZE_VALUE = 5
  ERROR = 6

  _VALUES_TO_NAMES = {
    1: "INVALID_METER_NAME",
    2: "INVALID_INDEX",
    3: "BAD_RATES_LIST",
    4: "INVALID_INFO_RATE_VALUE",
    5: "INVALID_BURST_SIZE_VALUE",
    6: "ERROR",
  }

  _NAMES_TO_VALUES = {
    "INVALID_METER_NAME": 1,
    "INVALID_INDEX": 2,
    "BAD_RATES_LIST": 3,
    "INVALID_INFO_RATE_VALUE": 4,
    "INVALID_BURST_SIZE_VALUE": 5,
    "ERROR": 6,
  }

class RegisterOperationErrorCode:
  INVALID_REGISTER_NAME = 1
  INVALID_INDEX = 2
  ERROR = 3

  _VALUES_TO_NAMES = {
    1: "INVALID_REGISTER_NAME",
    2: "INVALID_INDEX",
    3: "ERROR",
  }

  _NAMES_TO_VALUES = {
    "INVALID_REGISTER_NAME": 1,
    "INVALID_INDEX": 2,
    "ERROR": 3,
  }

class ParseVSetOperationErrorCode:
  INVALID_PARSE_VSET_NAME = 1
  ERROR = 2

  _VALUES_TO_NAMES = {
    1: "INVALID_PARSE_VSET_NAME",
    2: "ERROR",
  }

  _NAMES_TO_VALUES = {
    "INVALID_PARSE_VSET_NAME": 1,
    "ERROR": 2,
  }

class LearnOperationErrorCode:
  INVALID_LIST_ID = 1
  INVALID_LIST_NAME = 2
  ERROR = 3

  _VALUES_TO_NAMES = {
    1: "INVALID_LIST_ID",
    2: "INVALID_LIST_NAME",
    3: "ERROR",
  }

  _NAMES_TO_VALUES = {
    "INVALID_LIST_ID": 1,
    "INVALID_LIST_NAME": 2,
    "ERROR": 3,
  }

class DevMgrErrorCode:
  ERROR = 1

  _VALUES_TO_NAMES = {
    1: "ERROR",
  }

  _NAMES_TO_VALUES = {
    "ERROR": 1,
  }

class CrcErrorCode:
  INVALID_CALCULATION_NAME = 1
  WRONG_TYPE_CALCULATION = 2
  INVALID_CONFIG = 3

  _VALUES_TO_NAMES = {
    1: "INVALID_CALCULATION_NAME",
    2: "WRONG_TYPE_CALCULATION",
    3: "INVALID_CONFIG",
  }

  _NAMES_TO_VALUES = {
    "INVALID_CALCULATION_NAME": 1,
    "WRONG_TYPE_CALCULATION": 2,
    "INVALID_CONFIG": 3,
  }

class BmActionEntryType:
  NONE = 0
  ACTION_DATA = 1
  MBR_HANDLE = 2
  GRP_HANDLE = 3

  _VALUES_TO_NAMES = {
    0: "NONE",
    1: "ACTION_DATA",
    2: "MBR_HANDLE",
    3: "GRP_HANDLE",
  }

  _NAMES_TO_VALUES = {
    "NONE": 0,
    "ACTION_DATA": 1,
    "MBR_HANDLE": 2,
    "GRP_HANDLE": 3,
  }

class BmResourceType:
  MATCH_TABLE = 0
  ACTION_PROFILE = 1
  COUNTER = 2
  METER = 3
  REGISTER = 4
  LEARNING_LIST = 5

  _VALUES_TO_NAMES = {
    0: "MATCH_TABLE",
    1: "ACTION_PROFILE",
    2: "COUNTER",
    3: "METER",
    4: "REGISTER",
    5: "LEARNING_LIST",
  }

  _NAMES_TO_VALUES = {
    "MATCH_TABLE": 0,
    "ACTION_PROFILE": 1,
    "COUNTER": 2,
    "METER": 3,
    "REGISTER": 4,
    "LEARNING_LIST": 5,
  }

class IdLookupErrorCode:
  INVALID_RESOURCE_TYPE = 0
  INVALID_RESOURCE_NAME = 1

  _VALUES_TO_NAMES = {
    0: "INVALID_RESOURCE_TYPE",
    1: "INVALID_RESOURCE_NAME",
  }

  _NAMES_TO_VALUES = {
    "INVALID_RESOURCE_TYPE": 0,
    "INVALID_RESOURCE_NAME": 1,
  }


class BmMatchParamExact:
  """
  Attributes:
   - key
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
  )

  def __init__(self, key=None,):
    self.key = key

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BmMatchParamExact')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      if type(self.key) == str:
        oprot.writeString(self.key)
      else:
        oprot.writeBinary(self.key)  # modified for python3 port
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BmMatchParamLPM:
  """
  Attributes:
   - key
   - prefix_length
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I32, 'prefix_length', None, None, ), # 2
  )

  def __init__(self, key=None, prefix_length=None,):
    self.key = key
    self.prefix_length = prefix_length

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.prefix_length = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BmMatchParamLPM')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.prefix_length is not None:
      oprot.writeFieldBegin('prefix_length', TType.I32, 2)
      oprot.writeI32(self.prefix_length)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.prefix_length)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BmMatchParamTernary:
  """
  Attributes:
   - key
   - mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'mask', None, None, ), # 2
  )

  def __init__(self, key=None, mask=None,):
    self.key = key
    self.mask = mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.mask = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BmMatchParamTernary')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.mask is not None:
      oprot.writeFieldBegin('mask', TType.STRING, 2)
      oprot.writeString(self.mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BmMatchParamValid:
  """
  Attributes:
   - key
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'key', None, None, ), # 1
  )

  def __init__(self, key=None,):
    self.key = key

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.key = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BmMatchParamValid')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.BOOL, 1)
      oprot.writeBool(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BmMatchParamRange:
  """
  Attributes:
   - start
   - end_
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'start', None, None, ), # 1
    (2, TType.STRING, 'end_', None, None, ), # 2
  )

  def __init__(self, start=None, end_=None,):
    self.start = start
    self.end_ = end_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.start = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.end_ = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BmMatchParamRange')
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 1)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.end_ is not None:
      oprot.writeFieldBegin('end_', TType.STRING, 2)
      oprot.writeString(self.end_)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.end_)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BmMatchParam:
  """
  Attributes:
   - type
   - exact
   - lpm
   - ternary
   - valid
   - range
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.STRUCT, 'exact', (BmMatchParamExact, BmMatchParamExact.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'lpm', (BmMatchParamLPM, BmMatchParamLPM.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ternary', (BmMatchParamTernary, BmMatchParamTernary.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'valid', (BmMatchParamValid, BmMatchParamValid.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'range', (BmMatchParamRange, BmMatchParamRange.thrift_spec), None, ), # 6
  )

  def __init__(self, type=None, exact=None, lpm=None, ternary=None, valid=None, range=None,):
    self.type = type
    self.exact = exact
    self.lpm = lpm
    self.ternary = ternary
    self.valid = valid
    self.range = range

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.exact = BmMatchParamExact()
          self.exact.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.lpm = BmMatchParamLPM()
          self.lpm.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ternary = BmMatchParamTernary()
          self.ternary.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.valid = BmMatchParamValid()
          self.valid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.range = BmMatchParamRange()
          self.range.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BmMatchParam')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.exact is not None:
      oprot.writeFieldBegin('exact', TType.STRUCT, 2)
      self.exact.write(oprot)
      oprot.writeFieldEnd()
    if self.lpm is not None:
      oprot.writeFieldBegin('lpm', TType.STRUCT, 3)
      self.lpm.write(oprot)
      oprot.writeFieldEnd()
    if self.ternary is not None:
      oprot.writeFieldBegin('ternary', TType.STRUCT, 4)
      self.ternary.write(oprot)
      oprot.writeFieldEnd()
    if self.valid is not None:
      oprot.writeFieldBegin('valid', TType.STRUCT, 5)
      self.valid.write(oprot)
      oprot.writeFieldEnd()
    if self.range is not None:
      oprot.writeFieldBegin('range', TType.STRUCT, 6)
      self.range.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.exact)
    value = (value * 31) ^ hash(self.lpm)
    value = (value * 31) ^ hash(self.ternary)
    value = (value * 31) ^ hash(self.valid)
    value = (value * 31) ^ hash(self.range)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BmAddEntryOptions:
  """
  Attributes:
   - priority
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'priority', None, None, ), # 1
  )

  def __init__(self, priority=None,):
    self.priority = priority

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.priority = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BmAddEntryOptions')
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 1)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.priority)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BmCounterValue:
  """
  Attributes:
   - bytes
   - packets
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'bytes', None, None, ), # 1
    (2, TType.I64, 'packets', None, None, ), # 2
  )

  def __init__(self, bytes=None, packets=None,):
    self.bytes = bytes
    self.packets = packets

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.bytes = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.packets = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BmCounterValue')
    if self.bytes is not None:
      oprot.writeFieldBegin('bytes', TType.I64, 1)
      oprot.writeI64(self.bytes)
      oprot.writeFieldEnd()
    if self.packets is not None:
      oprot.writeFieldBegin('packets', TType.I64, 2)
      oprot.writeI64(self.packets)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.bytes)
    value = (value * 31) ^ hash(self.packets)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BmMeterRateConfig:
  """
  Attributes:
   - units_per_micros
   - burst_size
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'units_per_micros', None, None, ), # 1
    (2, TType.I32, 'burst_size', None, None, ), # 2
  )

  def __init__(self, units_per_micros=None, burst_size=None,):
    self.units_per_micros = units_per_micros
    self.burst_size = burst_size

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.units_per_micros = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.burst_size = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BmMeterRateConfig')
    if self.units_per_micros is not None:
      oprot.writeFieldBegin('units_per_micros', TType.DOUBLE, 1)
      oprot.writeDouble(self.units_per_micros)
      oprot.writeFieldEnd()
    if self.burst_size is not None:
      oprot.writeFieldBegin('burst_size', TType.I32, 2)
      oprot.writeI32(self.burst_size)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.units_per_micros)
    value = (value * 31) ^ hash(self.burst_size)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidTableOperation(TException):
  """
  Attributes:
   - code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'code', None, None, ), # 1
  )

  def __init__(self, code=None,):
    self.code = code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidTableOperation')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidCounterOperation(TException):
  """
  Attributes:
   - code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'code', None, None, ), # 1
  )

  def __init__(self, code=None,):
    self.code = code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidCounterOperation')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidSwapOperation(TException):
  """
  Attributes:
   - code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'code', None, None, ), # 1
  )

  def __init__(self, code=None,):
    self.code = code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidSwapOperation')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidMeterOperation(TException):
  """
  Attributes:
   - code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'code', None, None, ), # 1
  )

  def __init__(self, code=None,):
    self.code = code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidMeterOperation')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidRegisterOperation(TException):
  """
  Attributes:
   - code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'code', None, None, ), # 1
  )

  def __init__(self, code=None,):
    self.code = code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidRegisterOperation')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidParseVSetOperation(TException):
  """
  Attributes:
   - code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'code', None, None, ), # 1
  )

  def __init__(self, code=None,):
    self.code = code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidParseVSetOperation')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidLearnOperation(TException):
  """
  Attributes:
   - code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'code', None, None, ), # 1
  )

  def __init__(self, code=None,):
    self.code = code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidLearnOperation')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidDevMgrOperation(TException):
  """
  Attributes:
   - code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'code', None, None, ), # 1
  )

  def __init__(self, code=None,):
    self.code = code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidDevMgrOperation')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DevMgrPortInfo:
  """
  Attributes:
   - port_num
   - iface_name
   - is_up
   - extra
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'port_num', None, None, ), # 1
    (2, TType.STRING, 'iface_name', None, None, ), # 2
    (3, TType.BOOL, 'is_up', None, None, ), # 3
    (4, TType.MAP, 'extra', (TType.STRING,None,TType.STRING,None), None, ), # 4
  )

  def __init__(self, port_num=None, iface_name=None, is_up=None, extra=None,):
    self.port_num = port_num
    self.iface_name = iface_name
    self.is_up = is_up
    self.extra = extra

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.port_num = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.iface_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.is_up = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.extra = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin()
          for _i4 in xrange(_size0):
            _key5 = iprot.readString();
            _val6 = iprot.readString();
            self.extra[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DevMgrPortInfo')
    if self.port_num is not None:
      oprot.writeFieldBegin('port_num', TType.I32, 1)
      oprot.writeI32(self.port_num)
      oprot.writeFieldEnd()
    if self.iface_name is not None:
      oprot.writeFieldBegin('iface_name', TType.STRING, 2)
      oprot.writeString(self.iface_name)
      oprot.writeFieldEnd()
    if self.is_up is not None:
      oprot.writeFieldBegin('is_up', TType.BOOL, 3)
      oprot.writeBool(self.is_up)
      oprot.writeFieldEnd()
    if self.extra is not None:
      oprot.writeFieldBegin('extra', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extra))
      for kiter7,viter8 in self.extra.items():
        oprot.writeString(kiter7)
        oprot.writeString(viter8)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.port_num)
    value = (value * 31) ^ hash(self.iface_name)
    value = (value * 31) ^ hash(self.is_up)
    value = (value * 31) ^ hash(self.extra)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BmCrc16Config:
  """
  Attributes:
   - polynomial
   - initial_remainder
   - final_xor_value
   - data_reflected
   - remainder_reflected
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'polynomial', None, None, ), # 1
    (2, TType.I16, 'initial_remainder', None, None, ), # 2
    (3, TType.I16, 'final_xor_value', None, None, ), # 3
    (4, TType.BOOL, 'data_reflected', None, None, ), # 4
    (5, TType.BOOL, 'remainder_reflected', None, None, ), # 5
  )

  def __init__(self, polynomial=None, initial_remainder=None, final_xor_value=None, data_reflected=None, remainder_reflected=None,):
    self.polynomial = polynomial
    self.initial_remainder = initial_remainder
    self.final_xor_value = final_xor_value
    self.data_reflected = data_reflected
    self.remainder_reflected = remainder_reflected

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.polynomial = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.initial_remainder = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.final_xor_value = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.data_reflected = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.remainder_reflected = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BmCrc16Config')
    if self.polynomial is not None:
      oprot.writeFieldBegin('polynomial', TType.I16, 1)
      oprot.writeI16(self.polynomial)
      oprot.writeFieldEnd()
    if self.initial_remainder is not None:
      oprot.writeFieldBegin('initial_remainder', TType.I16, 2)
      oprot.writeI16(self.initial_remainder)
      oprot.writeFieldEnd()
    if self.final_xor_value is not None:
      oprot.writeFieldBegin('final_xor_value', TType.I16, 3)
      oprot.writeI16(self.final_xor_value)
      oprot.writeFieldEnd()
    if self.data_reflected is not None:
      oprot.writeFieldBegin('data_reflected', TType.BOOL, 4)
      oprot.writeBool(self.data_reflected)
      oprot.writeFieldEnd()
    if self.remainder_reflected is not None:
      oprot.writeFieldBegin('remainder_reflected', TType.BOOL, 5)
      oprot.writeBool(self.remainder_reflected)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.polynomial)
    value = (value * 31) ^ hash(self.initial_remainder)
    value = (value * 31) ^ hash(self.final_xor_value)
    value = (value * 31) ^ hash(self.data_reflected)
    value = (value * 31) ^ hash(self.remainder_reflected)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BmCrc32Config:
  """
  Attributes:
   - polynomial
   - initial_remainder
   - final_xor_value
   - data_reflected
   - remainder_reflected
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'polynomial', None, None, ), # 1
    (2, TType.I32, 'initial_remainder', None, None, ), # 2
    (3, TType.I32, 'final_xor_value', None, None, ), # 3
    (4, TType.BOOL, 'data_reflected', None, None, ), # 4
    (5, TType.BOOL, 'remainder_reflected', None, None, ), # 5
  )

  def __init__(self, polynomial=None, initial_remainder=None, final_xor_value=None, data_reflected=None, remainder_reflected=None,):
    self.polynomial = polynomial
    self.initial_remainder = initial_remainder
    self.final_xor_value = final_xor_value
    self.data_reflected = data_reflected
    self.remainder_reflected = remainder_reflected

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.polynomial = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.initial_remainder = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.final_xor_value = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.data_reflected = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.remainder_reflected = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BmCrc32Config')
    if self.polynomial is not None:
      oprot.writeFieldBegin('polynomial', TType.I32, 1)
      oprot.writeI32(self.polynomial)
      oprot.writeFieldEnd()
    if self.initial_remainder is not None:
      oprot.writeFieldBegin('initial_remainder', TType.I32, 2)
      oprot.writeI32(self.initial_remainder)
      oprot.writeFieldEnd()
    if self.final_xor_value is not None:
      oprot.writeFieldBegin('final_xor_value', TType.I32, 3)
      oprot.writeI32(self.final_xor_value)
      oprot.writeFieldEnd()
    if self.data_reflected is not None:
      oprot.writeFieldBegin('data_reflected', TType.BOOL, 4)
      oprot.writeBool(self.data_reflected)
      oprot.writeFieldEnd()
    if self.remainder_reflected is not None:
      oprot.writeFieldBegin('remainder_reflected', TType.BOOL, 5)
      oprot.writeBool(self.remainder_reflected)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.polynomial)
    value = (value * 31) ^ hash(self.initial_remainder)
    value = (value * 31) ^ hash(self.final_xor_value)
    value = (value * 31) ^ hash(self.data_reflected)
    value = (value * 31) ^ hash(self.remainder_reflected)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidCrcOperation(TException):
  """
  Attributes:
   - code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'code', None, None, ), # 1
  )

  def __init__(self, code=None,):
    self.code = code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidCrcOperation')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BmActionEntry:
  """
  Attributes:
   - action_type
   - action_name
   - action_data
   - mbr_handle
   - grp_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_type', None, None, ), # 1
    (2, TType.STRING, 'action_name', None, None, ), # 2
    (3, TType.LIST, 'action_data', (TType.STRING,None), None, ), # 3
    (4, TType.I32, 'mbr_handle', None, None, ), # 4
    (5, TType.I32, 'grp_handle', None, None, ), # 5
  )

  def __init__(self, action_type=None, action_name=None, action_data=None, mbr_handle=None, grp_handle=None,):
    self.action_type = action_type
    self.action_name = action_name
    self.action_data = action_data
    self.mbr_handle = mbr_handle
    self.grp_handle = grp_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.action_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.action_data = []
          (_etype12, _size9) = iprot.readListBegin()
          for _i13 in xrange(_size9):
            _elem14 = iprot.readString();
            self.action_data.append(_elem14)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.mbr_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.grp_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BmActionEntry')
    if self.action_type is not None:
      oprot.writeFieldBegin('action_type', TType.I32, 1)
      oprot.writeI32(self.action_type)
      oprot.writeFieldEnd()
    if self.action_name is not None:
      oprot.writeFieldBegin('action_name', TType.STRING, 2)
      oprot.writeString(self.action_name)
      oprot.writeFieldEnd()
    if self.action_data is not None:
      oprot.writeFieldBegin('action_data', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.action_data))
      for iter15 in self.action_data:
        oprot.writeString(iter15)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.mbr_handle is not None:
      oprot.writeFieldBegin('mbr_handle', TType.I32, 4)
      oprot.writeI32(self.mbr_handle)
      oprot.writeFieldEnd()
    if self.grp_handle is not None:
      oprot.writeFieldBegin('grp_handle', TType.I32, 5)
      oprot.writeI32(self.grp_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_type)
    value = (value * 31) ^ hash(self.action_name)
    value = (value * 31) ^ hash(self.action_data)
    value = (value * 31) ^ hash(self.mbr_handle)
    value = (value * 31) ^ hash(self.grp_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BmMtEntryLife:
  """
  Attributes:
   - timeout_ms
   - time_since_hit_ms
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'timeout_ms', None, None, ), # 1
    (2, TType.I32, 'time_since_hit_ms', None, None, ), # 2
  )

  def __init__(self, timeout_ms=None, time_since_hit_ms=None,):
    self.timeout_ms = timeout_ms
    self.time_since_hit_ms = time_since_hit_ms

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.timeout_ms = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.time_since_hit_ms = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BmMtEntryLife')
    if self.timeout_ms is not None:
      oprot.writeFieldBegin('timeout_ms', TType.I32, 1)
      oprot.writeI32(self.timeout_ms)
      oprot.writeFieldEnd()
    if self.time_since_hit_ms is not None:
      oprot.writeFieldBegin('time_since_hit_ms', TType.I32, 2)
      oprot.writeI32(self.time_since_hit_ms)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.timeout_ms)
    value = (value * 31) ^ hash(self.time_since_hit_ms)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BmMtEntry:
  """
  Attributes:
   - match_key
   - options
   - entry_handle
   - action_entry
   - life
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'match_key', (TType.STRUCT,(BmMatchParam, BmMatchParam.thrift_spec)), None, ), # 1
    (2, TType.STRUCT, 'options', (BmAddEntryOptions, BmAddEntryOptions.thrift_spec), None, ), # 2
    (3, TType.I32, 'entry_handle', None, None, ), # 3
    (4, TType.STRUCT, 'action_entry', (BmActionEntry, BmActionEntry.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'life', (BmMtEntryLife, BmMtEntryLife.thrift_spec), None, ), # 5
  )

  def __init__(self, match_key=None, options=None, entry_handle=None, action_entry=None, life=None,):
    self.match_key = match_key
    self.options = options
    self.entry_handle = entry_handle
    self.action_entry = action_entry
    self.life = life

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.match_key = []
          (_etype19, _size16) = iprot.readListBegin()
          for _i20 in xrange(_size16):
            _elem21 = BmMatchParam()
            _elem21.read(iprot)
            self.match_key.append(_elem21)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.options = BmAddEntryOptions()
          self.options.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.entry_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.action_entry = BmActionEntry()
          self.action_entry.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.life = BmMtEntryLife()
          self.life.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BmMtEntry')
    if self.match_key is not None:
      oprot.writeFieldBegin('match_key', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.match_key))
      for iter22 in self.match_key:
        iter22.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.options is not None:
      oprot.writeFieldBegin('options', TType.STRUCT, 2)
      self.options.write(oprot)
      oprot.writeFieldEnd()
    if self.entry_handle is not None:
      oprot.writeFieldBegin('entry_handle', TType.I32, 3)
      oprot.writeI32(self.entry_handle)
      oprot.writeFieldEnd()
    if self.action_entry is not None:
      oprot.writeFieldBegin('action_entry', TType.STRUCT, 4)
      self.action_entry.write(oprot)
      oprot.writeFieldEnd()
    if self.life is not None:
      oprot.writeFieldBegin('life', TType.STRUCT, 5)
      self.life.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_key)
    value = (value * 31) ^ hash(self.options)
    value = (value * 31) ^ hash(self.entry_handle)
    value = (value * 31) ^ hash(self.action_entry)
    value = (value * 31) ^ hash(self.life)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BmMtActProfMember:
  """
  Attributes:
   - mbr_handle
   - action_name
   - action_data
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'mbr_handle', None, None, ), # 1
    (2, TType.STRING, 'action_name', None, None, ), # 2
    (3, TType.LIST, 'action_data', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, mbr_handle=None, action_name=None, action_data=None,):
    self.mbr_handle = mbr_handle
    self.action_name = action_name
    self.action_data = action_data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.mbr_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.action_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.action_data = []
          (_etype26, _size23) = iprot.readListBegin()
          for _i27 in xrange(_size23):
            _elem28 = iprot.readString();
            self.action_data.append(_elem28)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BmMtActProfMember')
    if self.mbr_handle is not None:
      oprot.writeFieldBegin('mbr_handle', TType.I32, 1)
      oprot.writeI32(self.mbr_handle)
      oprot.writeFieldEnd()
    if self.action_name is not None:
      oprot.writeFieldBegin('action_name', TType.STRING, 2)
      oprot.writeString(self.action_name)
      oprot.writeFieldEnd()
    if self.action_data is not None:
      oprot.writeFieldBegin('action_data', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.action_data))
      for iter29 in self.action_data:
        oprot.writeString(iter29)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.mbr_handle)
    value = (value * 31) ^ hash(self.action_name)
    value = (value * 31) ^ hash(self.action_data)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BmMtActProfGroup:
  """
  Attributes:
   - grp_handle
   - mbr_handles
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'grp_handle', None, None, ), # 1
    (2, TType.LIST, 'mbr_handles', (TType.I32,None), None, ), # 2
  )

  def __init__(self, grp_handle=None, mbr_handles=None,):
    self.grp_handle = grp_handle
    self.mbr_handles = mbr_handles

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.grp_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.mbr_handles = []
          (_etype33, _size30) = iprot.readListBegin()
          for _i34 in xrange(_size30):
            _elem35 = iprot.readI32();
            self.mbr_handles.append(_elem35)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BmMtActProfGroup')
    if self.grp_handle is not None:
      oprot.writeFieldBegin('grp_handle', TType.I32, 1)
      oprot.writeI32(self.grp_handle)
      oprot.writeFieldEnd()
    if self.mbr_handles is not None:
      oprot.writeFieldBegin('mbr_handles', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.mbr_handles))
      for iter36 in self.mbr_handles:
        oprot.writeI32(iter36)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.grp_handle)
    value = (value * 31) ^ hash(self.mbr_handles)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BmConfig:
  """
  Attributes:
   - device_id
   - thrift_port
   - notifications_socket
   - elogger_socket
   - debugger_socket
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'device_id', None, None, ), # 1
    (2, TType.I32, 'thrift_port', None, None, ), # 2
    (3, TType.STRING, 'notifications_socket', None, None, ), # 3
    (4, TType.STRING, 'elogger_socket', None, None, ), # 4
    (5, TType.STRING, 'debugger_socket', None, None, ), # 5
  )

  def __init__(self, device_id=None, thrift_port=None, notifications_socket=None, elogger_socket=None, debugger_socket=None,):
    self.device_id = device_id
    self.thrift_port = thrift_port
    self.notifications_socket = notifications_socket
    self.elogger_socket = elogger_socket
    self.debugger_socket = debugger_socket

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.device_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.thrift_port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.notifications_socket = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.elogger_socket = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.debugger_socket = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BmConfig')
    if self.device_id is not None:
      oprot.writeFieldBegin('device_id', TType.I64, 1)
      oprot.writeI64(self.device_id)
      oprot.writeFieldEnd()
    if self.thrift_port is not None:
      oprot.writeFieldBegin('thrift_port', TType.I32, 2)
      oprot.writeI32(self.thrift_port)
      oprot.writeFieldEnd()
    if self.notifications_socket is not None:
      oprot.writeFieldBegin('notifications_socket', TType.STRING, 3)
      oprot.writeString(self.notifications_socket)
      oprot.writeFieldEnd()
    if self.elogger_socket is not None:
      oprot.writeFieldBegin('elogger_socket', TType.STRING, 4)
      oprot.writeString(self.elogger_socket)
      oprot.writeFieldEnd()
    if self.debugger_socket is not None:
      oprot.writeFieldBegin('debugger_socket', TType.STRING, 5)
      oprot.writeString(self.debugger_socket)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device_id)
    value = (value * 31) ^ hash(self.thrift_port)
    value = (value * 31) ^ hash(self.notifications_socket)
    value = (value * 31) ^ hash(self.elogger_socket)
    value = (value * 31) ^ hash(self.debugger_socket)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidIdLookup(TException):
  """
  Attributes:
   - code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'code', None, None, ), # 1
  )

  def __init__(self, code=None,):
    self.code = code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidIdLookup')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class McOperationErrorCode:
  TABLE_FULL = 1
  INVALID_MGID = 2
  INVALID_MGRP_HANDLE = 3
  INVALID_L1_HANDLE = 4
  ERROR = 5

  _VALUES_TO_NAMES = {
    1: "TABLE_FULL",
    2: "INVALID_MGID",
    3: "INVALID_MGRP_HANDLE",
    4: "INVALID_L1_HANDLE",
    5: "ERROR",
  }

  _NAMES_TO_VALUES = {
    "TABLE_FULL": 1,
    "INVALID_MGID": 2,
    "INVALID_MGRP_HANDLE": 3,
    "INVALID_L1_HANDLE": 4,
    "ERROR": 5,
  }


class InvalidMcOperation(TException):
  """
  Attributes:
   - code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'code', None, None, ), # 1
  )

  def __init__(self, code=None,):
    self.code = code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidMcOperation')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)